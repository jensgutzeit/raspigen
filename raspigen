#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'

RASPIGEN_VERSION = [0, 0, 2]

class Options
   def self.parse(args)
      options = OpenStruct.new
      options.size = 0
      options.image_name = 'gentoo.img'
      
      opt_parser = OptionParser.new do |opts|
         opts.banner = 'Usage: raspigen [options]'

         opts.on '-i', '--image NAME', 'Set name of image file [gentoo.img]' do |n|
            options.image_name = n
         end

         opts.on '-s', '--size IMAGESIZE', 'Set size of image in byte' do |s|
            options.size = s.to_i
         end

         opts.on_tail '-h', '--help', 'Show this message' do
            puts opts
            exit
         end

         opts.on_tail '--version', 'Show version' do
            puts "raspigen #{RASPIGEN_VERSION.join '.'}"
            exit
         end
      end

      opt_parser.parse! args
      options
   end
end

def ansi_colorize(text, color_code)
   "#{color_code}#{text}\033[0m"
end

def red(text)
   ansi_colorize text, "\033[1m\033[31m"
end

def green(text)
   ansi_colorize text, "\033[1m\033[32m"
end

def suceeded
   puts '[' + green('OK') + ']'
end

def failed
   puts '[' + red('FAILED') + ']'
end

def result(program_result)
   if program_result.success?
      suceeded
   else
      failed
      exit 1
   end
end

def create_disk_image(imageName, size)
   print "  Creating disk image '#{imageName}' (#{size} byte)... "
   
   begin
      s = "\0" * 65536
      File.open('gentoo.img', 'w+') do |f|
         while size >= 65536
            written = f.write s
            size -= written
         end

         if 0 != size
            s = "\0" * size
            written = f.write s
         end
      end

      suceeded
   rescue
      failed
      exit 1
   end
end

def use_image_as_loop_device(imageName, loopDevice)
   print "  Using '#{imageName}' as #{loopDevice} ... "
   output = `sudo losetup #{loopDevice} #{imageName}`
   result $?
end

def detach_loop_device(loopDevice)
   print "  Detaching '#{loopDevice}'... "
   output = `sudo losetup --detach #{loopDevice}`
   result $?
end

def create_partition(loopDevice, type, size, startSector)
   sizeBytes = size * 1024 * 1024
   sizeSectors = sizeBytes / 512
   endSector = startSector + sizeSectors
   output = `sudo parted -s #{loopDevice} unit s mkpart primary #{type} -- #{startSector} #{endSector}`
   result $?

   endSector
end

def create_partitions(loopDevice, boot_size = 96, swap_size = 512)
   puts "  Creating partitions..."

   print "    Creating new disklabel ... " 
   output = `sudo parted -s #{loopDevice} mklabel msdos`
   result $?

   puts "    Creating partition for /boot ..."

   print "      Creating a new primary partition (#{boot_size} MiB) ... "
   bootEndSector = create_partition loopDevice, 'fat32', boot_size, 2048

   print "      Making new partition bootable ... "
   output = `sudo parted -s #{loopDevice} set 1 boot on`
   result $?

   puts "    Creating new partition for /swap ... "

   print "      Creating a new primary partition (#{swap_size} MiB) ... "
   swapEndSector = create_partition loopDevice, 'linux-swap', swap_size, bootEndSector + 1

   print "    Creating new partition for / ... "
   output = `sudo parted -s #{loopDevice} unit s mkpart primary ext2 -- #{swapEndSector + 1} -1s`
   result $?
end

# Main program
options = Options.parse ARGV

puts "raspigen #{RASPIGEN_VERSION.join '.'}"
puts

if options.size <= 512 * 1024 * 1024
   puts "ERROR: Invalid disk image size (#{options.size} byte)"
   puts
   puts 'Please determine the size of your SD card for the Raspberry Pi and'
   puts 'pass this value with the option --size. At least 512 MiB are'
   puts 'required for this script.'

   exit 1
end

if 0 != options.size % 512
   suggestion = 512 * (options.size / 512)
   puts "ERROR: Size of disk image must be multiple of 512"
   puts
   puts "The next lower multiple of 512 is #{suggestion}."

   exit 1
end

loop_device = '/dev/loop0'

create_disk_image(options.image_name, options.size)
use_image_as_loop_device(options.image_name, loop_device)
create_partitions(loop_device)
detach_loop_device(loop_device)
