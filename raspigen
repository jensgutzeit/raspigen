#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'net/http'

RASPIGEN_VERSION = [0, 0, 4]

class Options
   def self.parse(args)
      options = OpenStruct.new
      options.size = 0
      options.image_name = 'gentoo.img'
      
      opt_parser = OptionParser.new do |opts|
         opts.banner = 'Usage: raspigen [options]'

         opts.on '-i', '--image NAME', 'Set name of image file [gentoo.img]' do |n|
            options.image_name = n
         end

         opts.on '-s', '--size IMAGESIZE', 'Set size of image in byte' do |s|
            options.size = s.to_i
         end

         opts.on_tail '-h', '--help', 'Show this message' do
            puts opts
            exit
         end

         opts.on_tail '--version', 'Show version' do
            puts "raspigen #{RASPIGEN_VERSION.join '.'}"
            exit
         end
      end

      opt_parser.parse! args
      options
   end
end

def ansi_colorize(text, color_code)
   "#{color_code}#{text}\033[0m"
end

def red(text)
   ansi_colorize text, "\033[1m\033[31m"
end

def green(text)
   ansi_colorize text, "\033[1m\033[32m"
end

def succeeded
   puts '[' + green('OK') + ']'
end

def failed
   puts '[' + red('FAILED') + ']'
end

def result(program_result)
   if program_result.success?
      succeeded
   else
      failed
      exit 1
   end
end

def create_disk_image(imageName, size)
   print "  Creating disk image '#{imageName}' (#{size} byte)... "
   `truncate -s #{size} #{imageName}`
   result $?
end

def use_image_as_loop_device(imageName, loopDevice)
   print "  Using '#{imageName}' as #{loopDevice} ... "
   output = `sudo losetup #{loopDevice} #{imageName}`
   result $?
end

def detach_loop_device(loopDevice)
   print "  Detaching '#{loopDevice}'... "
   output = `sudo losetup --detach #{loopDevice}`
   result $?
end

def create_partition(loopDevice, type, size, startSector)
   sizeBytes = size * 1024 * 1024
   sizeSectors = sizeBytes / 512
   endSector = startSector + sizeSectors - 1
   output = `sudo parted -s #{loopDevice} unit s mkpart primary #{type} -- #{startSector} #{endSector}`
   result $?

   endSector
end

def create_partitions(loopDevice, boot_size = 96, swap_size = 512)
   puts "  Creating partitions..."

   print "    Creating new disklabel ... " 
   output = `sudo parted -s #{loopDevice} mklabel msdos`
   result $?

   puts "    Creating partition for /boot ..."

   print "      Creating a new primary partition (#{boot_size} MiB) ... "
   bootEndSector = create_partition loopDevice, 'fat32', boot_size, 2048

   print "      Making new partition bootable ... "
   output = `sudo parted -s #{loopDevice} set 1 boot on`
   result $?

   puts "    Creating new partition for /swap ... "

   print "      Creating a new primary partition (#{swap_size} MiB) ... "
   swapEndSector = create_partition loopDevice, 'linux-swap', swap_size, bootEndSector + 1

   print "    Creating new partition for / ... "
   output = `sudo parted -s #{loopDevice} unit s mkpart primary ext2 -- #{swapEndSector + 1} -1s`
   result $?
end

def format_partitions(loopDevice)
   print "  Formatting /boot... "
   `sudo mkfs.msdos -F 16 #{loopDevice}p1 -n BOOT`
   result $?

   print "  Setting up swap area... "
   `sudo mkswap --label SWAP #{loopDevice}p2`
   result $?

   print "  Formatting /... "
   `sudo mkfs.ext4 -q -L ROOT #{loopDevice}p3`
   result $?
end

def mount_image(loopDevice)
   if not File.exist? 'gentoo'
      print "  Creating mount point (./gentoo)... "
      `sudo mkdir gentoo`
      result $?
   end

   print "  Mounting image's /... "
   `sudo mount #{loopDevice}p3 gentoo`
   result $?

   print "  Creating gentoo/boot... "
   `sudo mkdir gentoo/boot`
   result $?

   print "  Mounting image's /boot... "
   `sudo mount #{loopDevice}p1 gentoo/boot` 
   result $?
end

def latest_stage3(mirror)
   prefix = URI::join(mirror , 'releases/arm/autobuilds/')
   latestUri = URI::join(prefix , 'latest-stage3-armv6j_hardfp.txt')
   content = Net::HTTP.get(latestUri)   

   latestTarball = ""
   content.each_line("\n") do |line|
      line.strip!
      if not line.empty? and not line.start_with?("#")
         latestTarball = URI::join(prefix, line)
      end
   end

   return latestTarball.to_s
end

def sha512HashFromFile(fileName)
   File.open(fileName, "r") do |f|
      while (line = f.gets)
         if "# SHA512 HASH" == line.strip
            return f.gets.strip
         end
      end
   end

   return ""
end

def download_latest_stage3(mirror)
   latest = latest_stage3(mirror)
   fileName = File.basename(latest)

   if not File.exist?(fileName)
      print "  Downloading latest stage3 tarball... "
      `wget --quiet -c #{latest}`
      result $?
   end

   latestChecksums = latest + ".DIGESTS.asc"
   latestChecksumsFileName = File.basename(latestChecksums)
   if not File.exist?(latestChecksumsFileName)
      print "  Downloading checksums for stage3 tarball... "
      `wget --quiet -c #{latestChecksums}`
      result $?
   end

   print "  Validating stage3 checksums... "
   `gpg --verify #{latestChecksumsFileName} 2>&1`
   result $?

   print "  Calculating stage3 SHA-512 hash... "
   hash = `sha512sum #{fileName}`
   result $?

   print "  Verifying stage3 checksum... "
   if hash.strip == sha512HashFromFile(latestChecksumsFileName)
      succeeded
   else
      failed
      exit 1
   end

   fileName
end

def extract_stage3(fileName)
   print "  Extracting stage 3 image... "
   `sudo tar xfpj #{fileName} -C gentoo/`
   result $?
end

def unmount_image(loopDevice)
   print "  Unmounting gentoo/boot... "
   `sudo umount gentoo/boot`
   result $?

   print "  Unmounting gentoo... "
   `sudo umount gentoo`
   result $?
end

# Main program
options = Options.parse ARGV

puts "raspigen #{RASPIGEN_VERSION.join '.'}"
puts

if options.size <= 512 * 1024 * 1024
   puts "ERROR: Invalid disk image size (#{options.size} byte)"
   puts
   puts 'Please determine the size of your SD card for the Raspberry Pi and'
   puts 'pass this value with the option --size. At least 512 MiB are'
   puts 'required for this script.'

   exit 1
end

if 0 != options.size % 512
   suggestion = 512 * (options.size / 512)
   puts "ERROR: Size of disk image must be multiple of 512"
   puts
   puts "The next lower multiple of 512 is #{suggestion}."

   exit 1
end

loopDevice = '/dev/loop0'
mirror = 'http://de-mirror.org/gentoo/'

create_disk_image(options.image_name, options.size)
use_image_as_loop_device(options.image_name, loopDevice)
create_partitions(loopDevice)
format_partitions(loopDevice)
mount_image(loopDevice)
stage3FileName = download_latest_stage3(mirror)
extract_stage3(stage3FileName)
unmount_image(loopDevice)
detach_loop_device(loopDevice)
